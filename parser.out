Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decSeq
Rule 2     dec -> varDec
Rule 3     dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
Rule 4     dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
Rule 5     varDec -> type varSpecSeq SEMICOLON
Rule 6     varSpec -> ID
Rule 7     varSpec -> ID ASSIGN literal
Rule 8     varSpec -> ID LCOLC NUMBER RCOLC
Rule 9     varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE
Rule 10    type -> NUMBER
Rule 11    type -> STRING
Rule 12    type -> BOOL
Rule 13    param -> type ID
Rule 14    param -> type ID LCOLC RCOLC
Rule 15    block -> varDecList stmtList
Rule 16    stmt -> ifStmt
Rule 17    stmt -> whileStmt
Rule 18    stmt -> forStmt
Rule 19    stmt -> breakStmt
Rule 20    stmt -> returnStmt
Rule 21    stmt -> readStmt
Rule 22    stmt -> writeStmt
Rule 23    stmt -> assign SEMICOLON
Rule 24    stmt -> subCall SEMICOLON
Rule 25    ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE
Rule 26    ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE
Rule 27    whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE
Rule 28    forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
Rule 29    breakStmt -> BREAK SEMICOLON
Rule 30    readStmt -> READ var SEMICOLON
Rule 31    writeStmt -> WRITE expList SEMICOLON
Rule 32    returnStmt -> RETURN SEMICOLON
Rule 33    returnStmt -> RETURN exp SEMICOLON
Rule 34    subCall -> ID LPAREN expList RPAREN
Rule 35    assign -> var ASSIGN exp
Rule 36    assign -> var PLUS_EQ exp
Rule 37    assign -> var MINUS_EQ exp
Rule 38    assign -> var MULTIPLY_EQ exp
Rule 39    assign -> var DIVIDE_EQ exp
Rule 40    assign -> var MOD exp
Rule 41    var -> ID
Rule 42    var -> ID LCOLC exp RCOLC
Rule 43    exp -> exp PLUS exp
Rule 44    exp -> exp MINUS exp
Rule 45    exp -> exp MULTIPLY exp
Rule 46    exp -> exp DIVIDE exp
Rule 47    exp -> exp MOD exp
Rule 48    exp -> exp EQ exp
Rule 49    exp -> exp DIFF exp
Rule 50    exp -> exp LE exp
Rule 51    exp -> exp GE exp
Rule 52    exp -> exp GT exp
Rule 53    exp -> exp LT exp
Rule 54    exp -> exp AND exp
Rule 55    exp -> exp OR exp
Rule 56    exp -> NOT exp
Rule 57    exp -> MINUS exp
Rule 58    exp -> exp INTERROGATION exp COLON exp
Rule 59    exp -> subCall
Rule 60    exp -> var
Rule 61    exp -> literal
Rule 62    exp -> LPAREN exp RPAREN
Rule 63    exp -> param
Rule 64    literal -> CONST_NUMBER
Rule 65    literal -> CONST_STRING
Rule 66    literal -> TRUE
Rule 67    literal -> FALSE
Rule 68    paramList -> paramSeq
Rule 69    paramList -> empty
Rule 70    paramSeq -> param COMMA paramSeq
Rule 71    paramSeq -> param
Rule 72    varDecList -> varDec varDecList
Rule 73    varDecList -> empty
Rule 74    varSpecSeq -> varSpec COMMA varSpecSeq
Rule 75    varSpecSeq -> varSpec
Rule 76    expList -> expSeq
Rule 77    expList -> empty
Rule 78    literalSeq -> literal COMMA literalSeq
Rule 79    literalSeq -> literal
Rule 80    stmtList -> stmt stmtList
Rule 81    stmtList -> empty
Rule 82    decSeq -> dec decSeq
Rule 83    decSeq -> dec
Rule 84    expSeq -> exp COMMA expSeq
Rule 85    expSeq -> exp
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
ARROW                : 3 4 25 26 27 28
ASSIGN               : 7 9 35
BOOL                 : 12
BREAK                : 29
COLON                : 58
COMMA                : 70 74 78 84
CONST_NUMBER         : 64
CONST_STRING         : 65
DIFF                 : 49
DIVIDE               : 46
DIVIDE_EQ            : 39
ELSE                 : 26
EQ                   : 48
FALSE                : 67
FOR                  : 28
FUNC                 : 3 4
GE                   : 51
GT                   : 52
ID                   : 3 4 6 7 8 9 13 14 34 41 42
IF                   : 25 26
INTERROGATION        : 58
LBRACE               : 3 4 9 25 26 27 28
LCOLC                : 8 9 14 42
LE                   : 50
LPAREN               : 3 4 25 26 27 28 34 62
LT                   : 53
MINUS                : 44 57
MINUS_EQ             : 37
MOD                  : 40 47
MULTIPLY             : 45
MULTIPLY_EQ          : 38
NOT                  : 56
NUMBER               : 8 9 10
OR                   : 55
PLUS                 : 43
PLUS_EQ              : 36
RBRACE               : 3 4 9 25 26 26 26 27 28
RCOLC                : 8 9 14 42
READ                 : 30
RETURN               : 32 33
RPAREN               : 3 4 25 26 27 28 34 62
SEMICOLON            : 5 23 24 28 28 29 30 31 32 33
STRING               : 11
TRUE                 : 66
WHILE                : 27
WRITE                : 31
error                : 

Nonterminals, with rules where they appear

assign               : 23 28 28
block                : 3 4 25 26 26 27 28
breakStmt            : 19
dec                  : 82 83
decSeq               : 1 82
empty                : 69 73 77 81
exp                  : 25 26 27 28 33 35 36 37 38 39 40 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 57 58 58 58 62 84 85
expList              : 31 34
expSeq               : 76 84
forStmt              : 18
ifStmt               : 16
literal              : 7 61 78 79
literalSeq           : 9 78
param                : 63 70 71
paramList            : 3 4
paramSeq             : 68 70
program              : 0
readStmt             : 21
returnStmt           : 20
stmt                 : 80
stmtList             : 15 80
subCall              : 24 59
type                 : 4 5 13 14
var                  : 30 35 36 37 38 39 40 60
varDec               : 2 72
varDecList           : 15 72
varSpec              : 74 75
varSpecSeq           : 5 74
whileStmt            : 17
writeStmt            : 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decSeq
    (82) decSeq -> . dec decSeq
    (83) decSeq -> . dec
    (2) dec -> . varDec
    (3) dec -> . FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (4) dec -> . FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    FUNC            shift and go to state 5
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    program                        shift and go to state 1
    decSeq                         shift and go to state 2
    dec                            shift and go to state 3
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> decSeq .

    $end            reduce using rule 1 (program -> decSeq .)


state 3

    (82) decSeq -> dec . decSeq
    (83) decSeq -> dec .
    (82) decSeq -> . dec decSeq
    (83) decSeq -> . dec
    (2) dec -> . varDec
    (3) dec -> . FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (4) dec -> . FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    $end            reduce using rule 83 (decSeq -> dec .)
    FUNC            shift and go to state 5
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    dec                            shift and go to state 3
    decSeq                         shift and go to state 10
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 4

    (2) dec -> varDec .

    FUNC            reduce using rule 2 (dec -> varDec .)
    NUMBER          reduce using rule 2 (dec -> varDec .)
    STRING          reduce using rule 2 (dec -> varDec .)
    BOOL            reduce using rule 2 (dec -> varDec .)
    $end            reduce using rule 2 (dec -> varDec .)


state 5

    (3) dec -> FUNC . ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (4) dec -> FUNC . type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    ID              shift and go to state 11
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    type                           shift and go to state 12

state 6

    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec COMMA varSpecSeq
    (75) varSpecSeq -> . varSpec
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOLC NUMBER RCOLC
    (9) varSpec -> . ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE

    ID              shift and go to state 15

    varSpecSeq                     shift and go to state 13
    varSpec                        shift and go to state 14

state 7

    (10) type -> NUMBER .

    ID              reduce using rule 10 (type -> NUMBER .)


state 8

    (11) type -> STRING .

    ID              reduce using rule 11 (type -> STRING .)


state 9

    (12) type -> BOOL .

    ID              reduce using rule 12 (type -> BOOL .)


state 10

    (82) decSeq -> dec decSeq .

    $end            reduce using rule 82 (decSeq -> dec decSeq .)


state 11

    (3) dec -> FUNC ID . LPAREN paramList RPAREN ARROW LBRACE block RBRACE

    LPAREN          shift and go to state 16


state 12

    (4) dec -> FUNC type . ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE

    ID              shift and go to state 17


state 13

    (5) varDec -> type varSpecSeq . SEMICOLON

    SEMICOLON       shift and go to state 18


state 14

    (74) varSpecSeq -> varSpec . COMMA varSpecSeq
    (75) varSpecSeq -> varSpec .

    COMMA           shift and go to state 19
    SEMICOLON       reduce using rule 75 (varSpecSeq -> varSpec .)


state 15

    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOLC NUMBER RCOLC
    (9) varSpec -> ID . LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE

    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 20
    LCOLC           shift and go to state 21


state 16

    (3) dec -> FUNC ID LPAREN . paramList RPAREN ARROW LBRACE block RBRACE
    (68) paramList -> . paramSeq
    (69) paramList -> . empty
    (70) paramSeq -> . param COMMA paramSeq
    (71) paramSeq -> . param
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    RPAREN          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    paramList                      shift and go to state 22
    paramSeq                       shift and go to state 23
    empty                          shift and go to state 24
    param                          shift and go to state 25
    type                           shift and go to state 26

state 17

    (4) dec -> FUNC type ID . LPAREN paramList RPAREN ARROW LBRACE block RBRACE

    LPAREN          shift and go to state 27


state 18

    (5) varDec -> type varSpecSeq SEMICOLON .

    FUNC            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    NUMBER          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    STRING          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BOOL            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    $end            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    IF              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WHILE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    FOR             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BREAK           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RETURN          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    READ            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WRITE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    ID              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RBRACE          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)


state 19

    (74) varSpecSeq -> varSpec COMMA . varSpecSeq
    (74) varSpecSeq -> . varSpec COMMA varSpecSeq
    (75) varSpecSeq -> . varSpec
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOLC NUMBER RCOLC
    (9) varSpec -> . ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE

    ID              shift and go to state 15

    varSpec                        shift and go to state 14
    varSpecSeq                     shift and go to state 28

state 20

    (7) varSpec -> ID ASSIGN . literal
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE

    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    literal                        shift and go to state 29

state 21

    (8) varSpec -> ID LCOLC . NUMBER RCOLC
    (9) varSpec -> ID LCOLC . NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE

    NUMBER          shift and go to state 34


state 22

    (3) dec -> FUNC ID LPAREN paramList . RPAREN ARROW LBRACE block RBRACE

    RPAREN          shift and go to state 35


state 23

    (68) paramList -> paramSeq .

    RPAREN          reduce using rule 68 (paramList -> paramSeq .)


state 24

    (69) paramList -> empty .

    RPAREN          reduce using rule 69 (paramList -> empty .)


state 25

    (70) paramSeq -> param . COMMA paramSeq
    (71) paramSeq -> param .

    COMMA           shift and go to state 36
    RPAREN          reduce using rule 71 (paramSeq -> param .)


state 26

    (13) param -> type . ID
    (14) param -> type . ID LCOLC RCOLC

    ID              shift and go to state 37


state 27

    (4) dec -> FUNC type ID LPAREN . paramList RPAREN ARROW LBRACE block RBRACE
    (68) paramList -> . paramSeq
    (69) paramList -> . empty
    (70) paramSeq -> . param COMMA paramSeq
    (71) paramSeq -> . param
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    RPAREN          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    type                           shift and go to state 26
    paramList                      shift and go to state 38
    paramSeq                       shift and go to state 23
    empty                          shift and go to state 24
    param                          shift and go to state 25

state 28

    (74) varSpecSeq -> varSpec COMMA varSpecSeq .

    SEMICOLON       reduce using rule 74 (varSpecSeq -> varSpec COMMA varSpecSeq .)


state 29

    (7) varSpec -> ID ASSIGN literal .

    COMMA           reduce using rule 7 (varSpec -> ID ASSIGN literal .)
    SEMICOLON       reduce using rule 7 (varSpec -> ID ASSIGN literal .)


state 30

    (64) literal -> CONST_NUMBER .

    COMMA           reduce using rule 64 (literal -> CONST_NUMBER .)
    SEMICOLON       reduce using rule 64 (literal -> CONST_NUMBER .)
    RBRACE          reduce using rule 64 (literal -> CONST_NUMBER .)
    PLUS            reduce using rule 64 (literal -> CONST_NUMBER .)
    MINUS           reduce using rule 64 (literal -> CONST_NUMBER .)
    MULTIPLY        reduce using rule 64 (literal -> CONST_NUMBER .)
    DIVIDE          reduce using rule 64 (literal -> CONST_NUMBER .)
    MOD             reduce using rule 64 (literal -> CONST_NUMBER .)
    EQ              reduce using rule 64 (literal -> CONST_NUMBER .)
    DIFF            reduce using rule 64 (literal -> CONST_NUMBER .)
    LE              reduce using rule 64 (literal -> CONST_NUMBER .)
    GE              reduce using rule 64 (literal -> CONST_NUMBER .)
    GT              reduce using rule 64 (literal -> CONST_NUMBER .)
    LT              reduce using rule 64 (literal -> CONST_NUMBER .)
    AND             reduce using rule 64 (literal -> CONST_NUMBER .)
    OR              reduce using rule 64 (literal -> CONST_NUMBER .)
    INTERROGATION   reduce using rule 64 (literal -> CONST_NUMBER .)
    RPAREN          reduce using rule 64 (literal -> CONST_NUMBER .)
    RCOLC           reduce using rule 64 (literal -> CONST_NUMBER .)
    COLON           reduce using rule 64 (literal -> CONST_NUMBER .)


state 31

    (65) literal -> CONST_STRING .

    COMMA           reduce using rule 65 (literal -> CONST_STRING .)
    SEMICOLON       reduce using rule 65 (literal -> CONST_STRING .)
    RBRACE          reduce using rule 65 (literal -> CONST_STRING .)
    PLUS            reduce using rule 65 (literal -> CONST_STRING .)
    MINUS           reduce using rule 65 (literal -> CONST_STRING .)
    MULTIPLY        reduce using rule 65 (literal -> CONST_STRING .)
    DIVIDE          reduce using rule 65 (literal -> CONST_STRING .)
    MOD             reduce using rule 65 (literal -> CONST_STRING .)
    EQ              reduce using rule 65 (literal -> CONST_STRING .)
    DIFF            reduce using rule 65 (literal -> CONST_STRING .)
    LE              reduce using rule 65 (literal -> CONST_STRING .)
    GE              reduce using rule 65 (literal -> CONST_STRING .)
    GT              reduce using rule 65 (literal -> CONST_STRING .)
    LT              reduce using rule 65 (literal -> CONST_STRING .)
    AND             reduce using rule 65 (literal -> CONST_STRING .)
    OR              reduce using rule 65 (literal -> CONST_STRING .)
    INTERROGATION   reduce using rule 65 (literal -> CONST_STRING .)
    RPAREN          reduce using rule 65 (literal -> CONST_STRING .)
    RCOLC           reduce using rule 65 (literal -> CONST_STRING .)
    COLON           reduce using rule 65 (literal -> CONST_STRING .)


state 32

    (66) literal -> TRUE .

    COMMA           reduce using rule 66 (literal -> TRUE .)
    SEMICOLON       reduce using rule 66 (literal -> TRUE .)
    RBRACE          reduce using rule 66 (literal -> TRUE .)
    PLUS            reduce using rule 66 (literal -> TRUE .)
    MINUS           reduce using rule 66 (literal -> TRUE .)
    MULTIPLY        reduce using rule 66 (literal -> TRUE .)
    DIVIDE          reduce using rule 66 (literal -> TRUE .)
    MOD             reduce using rule 66 (literal -> TRUE .)
    EQ              reduce using rule 66 (literal -> TRUE .)
    DIFF            reduce using rule 66 (literal -> TRUE .)
    LE              reduce using rule 66 (literal -> TRUE .)
    GE              reduce using rule 66 (literal -> TRUE .)
    GT              reduce using rule 66 (literal -> TRUE .)
    LT              reduce using rule 66 (literal -> TRUE .)
    AND             reduce using rule 66 (literal -> TRUE .)
    OR              reduce using rule 66 (literal -> TRUE .)
    INTERROGATION   reduce using rule 66 (literal -> TRUE .)
    RPAREN          reduce using rule 66 (literal -> TRUE .)
    RCOLC           reduce using rule 66 (literal -> TRUE .)
    COLON           reduce using rule 66 (literal -> TRUE .)


state 33

    (67) literal -> FALSE .

    COMMA           reduce using rule 67 (literal -> FALSE .)
    SEMICOLON       reduce using rule 67 (literal -> FALSE .)
    RBRACE          reduce using rule 67 (literal -> FALSE .)
    PLUS            reduce using rule 67 (literal -> FALSE .)
    MINUS           reduce using rule 67 (literal -> FALSE .)
    MULTIPLY        reduce using rule 67 (literal -> FALSE .)
    DIVIDE          reduce using rule 67 (literal -> FALSE .)
    MOD             reduce using rule 67 (literal -> FALSE .)
    EQ              reduce using rule 67 (literal -> FALSE .)
    DIFF            reduce using rule 67 (literal -> FALSE .)
    LE              reduce using rule 67 (literal -> FALSE .)
    GE              reduce using rule 67 (literal -> FALSE .)
    GT              reduce using rule 67 (literal -> FALSE .)
    LT              reduce using rule 67 (literal -> FALSE .)
    AND             reduce using rule 67 (literal -> FALSE .)
    OR              reduce using rule 67 (literal -> FALSE .)
    INTERROGATION   reduce using rule 67 (literal -> FALSE .)
    RPAREN          reduce using rule 67 (literal -> FALSE .)
    RCOLC           reduce using rule 67 (literal -> FALSE .)
    COLON           reduce using rule 67 (literal -> FALSE .)


state 34

    (8) varSpec -> ID LCOLC NUMBER . RCOLC
    (9) varSpec -> ID LCOLC NUMBER . RCOLC ASSIGN LBRACE literalSeq RBRACE

    RCOLC           shift and go to state 39


state 35

    (3) dec -> FUNC ID LPAREN paramList RPAREN . ARROW LBRACE block RBRACE

    ARROW           shift and go to state 40


state 36

    (70) paramSeq -> param COMMA . paramSeq
    (70) paramSeq -> . param COMMA paramSeq
    (71) paramSeq -> . param
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    param                          shift and go to state 25
    paramSeq                       shift and go to state 41
    type                           shift and go to state 26

state 37

    (13) param -> type ID .
    (14) param -> type ID . LCOLC RCOLC

    COMMA           reduce using rule 13 (param -> type ID .)
    RPAREN          reduce using rule 13 (param -> type ID .)
    SEMICOLON       reduce using rule 13 (param -> type ID .)
    PLUS            reduce using rule 13 (param -> type ID .)
    MINUS           reduce using rule 13 (param -> type ID .)
    MULTIPLY        reduce using rule 13 (param -> type ID .)
    DIVIDE          reduce using rule 13 (param -> type ID .)
    MOD             reduce using rule 13 (param -> type ID .)
    EQ              reduce using rule 13 (param -> type ID .)
    DIFF            reduce using rule 13 (param -> type ID .)
    LE              reduce using rule 13 (param -> type ID .)
    GE              reduce using rule 13 (param -> type ID .)
    GT              reduce using rule 13 (param -> type ID .)
    LT              reduce using rule 13 (param -> type ID .)
    AND             reduce using rule 13 (param -> type ID .)
    OR              reduce using rule 13 (param -> type ID .)
    INTERROGATION   reduce using rule 13 (param -> type ID .)
    RCOLC           reduce using rule 13 (param -> type ID .)
    COLON           reduce using rule 13 (param -> type ID .)
    LCOLC           shift and go to state 42


state 38

    (4) dec -> FUNC type ID LPAREN paramList . RPAREN ARROW LBRACE block RBRACE

    RPAREN          shift and go to state 43


state 39

    (8) varSpec -> ID LCOLC NUMBER RCOLC .
    (9) varSpec -> ID LCOLC NUMBER RCOLC . ASSIGN LBRACE literalSeq RBRACE

    COMMA           reduce using rule 8 (varSpec -> ID LCOLC NUMBER RCOLC .)
    SEMICOLON       reduce using rule 8 (varSpec -> ID LCOLC NUMBER RCOLC .)
    ASSIGN          shift and go to state 44


state 40

    (3) dec -> FUNC ID LPAREN paramList RPAREN ARROW . LBRACE block RBRACE

    LBRACE          shift and go to state 45


state 41

    (70) paramSeq -> param COMMA paramSeq .

    RPAREN          reduce using rule 70 (paramSeq -> param COMMA paramSeq .)


state 42

    (14) param -> type ID LCOLC . RCOLC

    RCOLC           shift and go to state 46


state 43

    (4) dec -> FUNC type ID LPAREN paramList RPAREN . ARROW LBRACE block RBRACE

    ARROW           shift and go to state 47


state 44

    (9) varSpec -> ID LCOLC NUMBER RCOLC ASSIGN . LBRACE literalSeq RBRACE

    LBRACE          shift and go to state 48


state 45

    (3) dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 49
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 46

    (14) param -> type ID LCOLC RCOLC .

    COMMA           reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    RPAREN          reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    SEMICOLON       reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    PLUS            reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    MINUS           reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    MULTIPLY        reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    DIVIDE          reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    MOD             reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    EQ              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    DIFF            reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    LE              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    GE              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    GT              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    LT              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    AND             reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    OR              reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    INTERROGATION   reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    RCOLC           reduce using rule 14 (param -> type ID LCOLC RCOLC .)
    COLON           reduce using rule 14 (param -> type ID LCOLC RCOLC .)


state 47

    (4) dec -> FUNC type ID LPAREN paramList RPAREN ARROW . LBRACE block RBRACE

    LBRACE          shift and go to state 53


state 48

    (9) varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE . literalSeq RBRACE
    (78) literalSeq -> . literal COMMA literalSeq
    (79) literalSeq -> . literal
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE

    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    literalSeq                     shift and go to state 54
    literal                        shift and go to state 55

state 49

    (3) dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block . RBRACE

    RBRACE          shift and go to state 56


state 50

    (15) block -> varDecList . stmtList
    (80) stmtList -> . stmt stmtList
    (81) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (86) empty -> .
    (25) ifStmt -> . IF LPAREN exp RPAREN ARROW LBRACE block RBRACE
    (26) ifStmt -> . IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE
    (27) whileStmt -> . WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE
    (28) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
    (29) breakStmt -> . BREAK SEMICOLON
    (32) returnStmt -> . RETURN SEMICOLON
    (33) returnStmt -> . RETURN exp SEMICOLON
    (30) readStmt -> . READ var SEMICOLON
    (31) writeStmt -> . WRITE expList SEMICOLON
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUS_EQ exp
    (37) assign -> . var MINUS_EQ exp
    (38) assign -> . var MULTIPLY_EQ exp
    (39) assign -> . var DIVIDE_EQ exp
    (40) assign -> . var MOD exp
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC

    RBRACE          reduce using rule 86 (empty -> .)
    IF              shift and go to state 69
    WHILE           shift and go to state 70
    FOR             shift and go to state 71
    BREAK           shift and go to state 72
    RETURN          shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 76
    ID              shift and go to state 77

    stmtList                       shift and go to state 57
    stmt                           shift and go to state 58
    empty                          shift and go to state 59
    ifStmt                         shift and go to state 60
    whileStmt                      shift and go to state 61
    forStmt                        shift and go to state 62
    breakStmt                      shift and go to state 63
    returnStmt                     shift and go to state 64
    readStmt                       shift and go to state 65
    writeStmt                      shift and go to state 66
    assign                         shift and go to state 67
    subCall                        shift and go to state 68
    var                            shift and go to state 75

state 51

    (72) varDecList -> varDec . varDecList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    varDec                         shift and go to state 51
    varDecList                     shift and go to state 78
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 52

    (73) varDecList -> empty .

    IF              reduce using rule 73 (varDecList -> empty .)
    WHILE           reduce using rule 73 (varDecList -> empty .)
    FOR             reduce using rule 73 (varDecList -> empty .)
    BREAK           reduce using rule 73 (varDecList -> empty .)
    RETURN          reduce using rule 73 (varDecList -> empty .)
    READ            reduce using rule 73 (varDecList -> empty .)
    WRITE           reduce using rule 73 (varDecList -> empty .)
    ID              reduce using rule 73 (varDecList -> empty .)
    RBRACE          reduce using rule 73 (varDecList -> empty .)


state 53

    (4) dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    type                           shift and go to state 6
    block                          shift and go to state 79
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52

state 54

    (9) varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq . RBRACE

    RBRACE          shift and go to state 80


state 55

    (78) literalSeq -> literal . COMMA literalSeq
    (79) literalSeq -> literal .

    COMMA           shift and go to state 81
    RBRACE          reduce using rule 79 (literalSeq -> literal .)


state 56

    (3) dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .

    FUNC            reduce using rule 3 (dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    NUMBER          reduce using rule 3 (dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    STRING          reduce using rule 3 (dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    BOOL            reduce using rule 3 (dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    $end            reduce using rule 3 (dec -> FUNC ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)


state 57

    (15) block -> varDecList stmtList .

    RBRACE          reduce using rule 15 (block -> varDecList stmtList .)


state 58

    (80) stmtList -> stmt . stmtList
    (80) stmtList -> . stmt stmtList
    (81) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (86) empty -> .
    (25) ifStmt -> . IF LPAREN exp RPAREN ARROW LBRACE block RBRACE
    (26) ifStmt -> . IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE
    (27) whileStmt -> . WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE
    (28) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
    (29) breakStmt -> . BREAK SEMICOLON
    (32) returnStmt -> . RETURN SEMICOLON
    (33) returnStmt -> . RETURN exp SEMICOLON
    (30) readStmt -> . READ var SEMICOLON
    (31) writeStmt -> . WRITE expList SEMICOLON
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUS_EQ exp
    (37) assign -> . var MINUS_EQ exp
    (38) assign -> . var MULTIPLY_EQ exp
    (39) assign -> . var DIVIDE_EQ exp
    (40) assign -> . var MOD exp
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC

    RBRACE          reduce using rule 86 (empty -> .)
    IF              shift and go to state 69
    WHILE           shift and go to state 70
    FOR             shift and go to state 71
    BREAK           shift and go to state 72
    RETURN          shift and go to state 73
    READ            shift and go to state 74
    WRITE           shift and go to state 76
    ID              shift and go to state 77

    stmt                           shift and go to state 58
    stmtList                       shift and go to state 82
    empty                          shift and go to state 59
    ifStmt                         shift and go to state 60
    whileStmt                      shift and go to state 61
    forStmt                        shift and go to state 62
    breakStmt                      shift and go to state 63
    returnStmt                     shift and go to state 64
    readStmt                       shift and go to state 65
    writeStmt                      shift and go to state 66
    assign                         shift and go to state 67
    subCall                        shift and go to state 68
    var                            shift and go to state 75

state 59

    (81) stmtList -> empty .

    RBRACE          reduce using rule 81 (stmtList -> empty .)


state 60

    (16) stmt -> ifStmt .

    IF              reduce using rule 16 (stmt -> ifStmt .)
    WHILE           reduce using rule 16 (stmt -> ifStmt .)
    FOR             reduce using rule 16 (stmt -> ifStmt .)
    BREAK           reduce using rule 16 (stmt -> ifStmt .)
    RETURN          reduce using rule 16 (stmt -> ifStmt .)
    READ            reduce using rule 16 (stmt -> ifStmt .)
    WRITE           reduce using rule 16 (stmt -> ifStmt .)
    ID              reduce using rule 16 (stmt -> ifStmt .)
    RBRACE          reduce using rule 16 (stmt -> ifStmt .)


state 61

    (17) stmt -> whileStmt .

    IF              reduce using rule 17 (stmt -> whileStmt .)
    WHILE           reduce using rule 17 (stmt -> whileStmt .)
    FOR             reduce using rule 17 (stmt -> whileStmt .)
    BREAK           reduce using rule 17 (stmt -> whileStmt .)
    RETURN          reduce using rule 17 (stmt -> whileStmt .)
    READ            reduce using rule 17 (stmt -> whileStmt .)
    WRITE           reduce using rule 17 (stmt -> whileStmt .)
    ID              reduce using rule 17 (stmt -> whileStmt .)
    RBRACE          reduce using rule 17 (stmt -> whileStmt .)


state 62

    (18) stmt -> forStmt .

    IF              reduce using rule 18 (stmt -> forStmt .)
    WHILE           reduce using rule 18 (stmt -> forStmt .)
    FOR             reduce using rule 18 (stmt -> forStmt .)
    BREAK           reduce using rule 18 (stmt -> forStmt .)
    RETURN          reduce using rule 18 (stmt -> forStmt .)
    READ            reduce using rule 18 (stmt -> forStmt .)
    WRITE           reduce using rule 18 (stmt -> forStmt .)
    ID              reduce using rule 18 (stmt -> forStmt .)
    RBRACE          reduce using rule 18 (stmt -> forStmt .)


state 63

    (19) stmt -> breakStmt .

    IF              reduce using rule 19 (stmt -> breakStmt .)
    WHILE           reduce using rule 19 (stmt -> breakStmt .)
    FOR             reduce using rule 19 (stmt -> breakStmt .)
    BREAK           reduce using rule 19 (stmt -> breakStmt .)
    RETURN          reduce using rule 19 (stmt -> breakStmt .)
    READ            reduce using rule 19 (stmt -> breakStmt .)
    WRITE           reduce using rule 19 (stmt -> breakStmt .)
    ID              reduce using rule 19 (stmt -> breakStmt .)
    RBRACE          reduce using rule 19 (stmt -> breakStmt .)


state 64

    (20) stmt -> returnStmt .

    IF              reduce using rule 20 (stmt -> returnStmt .)
    WHILE           reduce using rule 20 (stmt -> returnStmt .)
    FOR             reduce using rule 20 (stmt -> returnStmt .)
    BREAK           reduce using rule 20 (stmt -> returnStmt .)
    RETURN          reduce using rule 20 (stmt -> returnStmt .)
    READ            reduce using rule 20 (stmt -> returnStmt .)
    WRITE           reduce using rule 20 (stmt -> returnStmt .)
    ID              reduce using rule 20 (stmt -> returnStmt .)
    RBRACE          reduce using rule 20 (stmt -> returnStmt .)


state 65

    (21) stmt -> readStmt .

    IF              reduce using rule 21 (stmt -> readStmt .)
    WHILE           reduce using rule 21 (stmt -> readStmt .)
    FOR             reduce using rule 21 (stmt -> readStmt .)
    BREAK           reduce using rule 21 (stmt -> readStmt .)
    RETURN          reduce using rule 21 (stmt -> readStmt .)
    READ            reduce using rule 21 (stmt -> readStmt .)
    WRITE           reduce using rule 21 (stmt -> readStmt .)
    ID              reduce using rule 21 (stmt -> readStmt .)
    RBRACE          reduce using rule 21 (stmt -> readStmt .)


state 66

    (22) stmt -> writeStmt .

    IF              reduce using rule 22 (stmt -> writeStmt .)
    WHILE           reduce using rule 22 (stmt -> writeStmt .)
    FOR             reduce using rule 22 (stmt -> writeStmt .)
    BREAK           reduce using rule 22 (stmt -> writeStmt .)
    RETURN          reduce using rule 22 (stmt -> writeStmt .)
    READ            reduce using rule 22 (stmt -> writeStmt .)
    WRITE           reduce using rule 22 (stmt -> writeStmt .)
    ID              reduce using rule 22 (stmt -> writeStmt .)
    RBRACE          reduce using rule 22 (stmt -> writeStmt .)


state 67

    (23) stmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 83


state 68

    (24) stmt -> subCall . SEMICOLON

    SEMICOLON       shift and go to state 84


state 69

    (25) ifStmt -> IF . LPAREN exp RPAREN ARROW LBRACE block RBRACE
    (26) ifStmt -> IF . LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE

    LPAREN          shift and go to state 85


state 70

    (27) whileStmt -> WHILE . LPAREN exp RPAREN ARROW LBRACE block RBRACE

    LPAREN          shift and go to state 86


state 71

    (28) forStmt -> FOR . LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE

    LPAREN          shift and go to state 87


state 72

    (29) breakStmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 88


state 73

    (32) returnStmt -> RETURN . SEMICOLON
    (33) returnStmt -> RETURN . exp SEMICOLON
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    SEMICOLON       shift and go to state 89
    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 90
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 74

    (30) readStmt -> READ . var SEMICOLON
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC

    ID              shift and go to state 99

    var                            shift and go to state 98

state 75

    (35) assign -> var . ASSIGN exp
    (36) assign -> var . PLUS_EQ exp
    (37) assign -> var . MINUS_EQ exp
    (38) assign -> var . MULTIPLY_EQ exp
    (39) assign -> var . DIVIDE_EQ exp
    (40) assign -> var . MOD exp

    ASSIGN          shift and go to state 100
    PLUS_EQ         shift and go to state 101
    MINUS_EQ        shift and go to state 102
    MULTIPLY_EQ     shift and go to state 103
    DIVIDE_EQ       shift and go to state 104
    MOD             shift and go to state 105


state 76

    (31) writeStmt -> WRITE . expList SEMICOLON
    (76) expList -> . expSeq
    (77) expList -> . empty
    (84) expSeq -> . exp COMMA expSeq
    (85) expSeq -> . exp
    (86) empty -> .
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    SEMICOLON       reduce using rule 86 (empty -> .)
    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    expList                        shift and go to state 106
    expSeq                         shift and go to state 107
    empty                          shift and go to state 108
    exp                            shift and go to state 109
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 77

    (34) subCall -> ID . LPAREN expList RPAREN
    (41) var -> ID .
    (42) var -> ID . LCOLC exp RCOLC

    LPAREN          shift and go to state 110
    ASSIGN          reduce using rule 41 (var -> ID .)
    PLUS_EQ         reduce using rule 41 (var -> ID .)
    MINUS_EQ        reduce using rule 41 (var -> ID .)
    MULTIPLY_EQ     reduce using rule 41 (var -> ID .)
    DIVIDE_EQ       reduce using rule 41 (var -> ID .)
    MOD             reduce using rule 41 (var -> ID .)
    SEMICOLON       reduce using rule 41 (var -> ID .)
    PLUS            reduce using rule 41 (var -> ID .)
    MINUS           reduce using rule 41 (var -> ID .)
    MULTIPLY        reduce using rule 41 (var -> ID .)
    DIVIDE          reduce using rule 41 (var -> ID .)
    EQ              reduce using rule 41 (var -> ID .)
    DIFF            reduce using rule 41 (var -> ID .)
    LE              reduce using rule 41 (var -> ID .)
    GE              reduce using rule 41 (var -> ID .)
    GT              reduce using rule 41 (var -> ID .)
    LT              reduce using rule 41 (var -> ID .)
    AND             reduce using rule 41 (var -> ID .)
    OR              reduce using rule 41 (var -> ID .)
    INTERROGATION   reduce using rule 41 (var -> ID .)
    COMMA           reduce using rule 41 (var -> ID .)
    RPAREN          reduce using rule 41 (var -> ID .)
    RCOLC           reduce using rule 41 (var -> ID .)
    COLON           reduce using rule 41 (var -> ID .)
    LCOLC           shift and go to state 111


state 78

    (72) varDecList -> varDec varDecList .

    IF              reduce using rule 72 (varDecList -> varDec varDecList .)
    WHILE           reduce using rule 72 (varDecList -> varDec varDecList .)
    FOR             reduce using rule 72 (varDecList -> varDec varDecList .)
    BREAK           reduce using rule 72 (varDecList -> varDec varDecList .)
    RETURN          reduce using rule 72 (varDecList -> varDec varDecList .)
    READ            reduce using rule 72 (varDecList -> varDec varDecList .)
    WRITE           reduce using rule 72 (varDecList -> varDec varDecList .)
    ID              reduce using rule 72 (varDecList -> varDec varDecList .)
    RBRACE          reduce using rule 72 (varDecList -> varDec varDecList .)


state 79

    (4) dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block . RBRACE

    RBRACE          shift and go to state 112


state 80

    (9) varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE .

    COMMA           reduce using rule 9 (varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE .)
    SEMICOLON       reduce using rule 9 (varSpec -> ID LCOLC NUMBER RCOLC ASSIGN LBRACE literalSeq RBRACE .)


state 81

    (78) literalSeq -> literal COMMA . literalSeq
    (78) literalSeq -> . literal COMMA literalSeq
    (79) literalSeq -> . literal
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE

    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33

    literal                        shift and go to state 55
    literalSeq                     shift and go to state 113

state 82

    (80) stmtList -> stmt stmtList .

    RBRACE          reduce using rule 80 (stmtList -> stmt stmtList .)


state 83

    (23) stmt -> assign SEMICOLON .

    IF              reduce using rule 23 (stmt -> assign SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> assign SEMICOLON .)
    BREAK           reduce using rule 23 (stmt -> assign SEMICOLON .)
    RETURN          reduce using rule 23 (stmt -> assign SEMICOLON .)
    READ            reduce using rule 23 (stmt -> assign SEMICOLON .)
    WRITE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    ID              reduce using rule 23 (stmt -> assign SEMICOLON .)
    RBRACE          reduce using rule 23 (stmt -> assign SEMICOLON .)


state 84

    (24) stmt -> subCall SEMICOLON .

    IF              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    FOR             reduce using rule 24 (stmt -> subCall SEMICOLON .)
    BREAK           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> subCall SEMICOLON .)
    READ            reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WRITE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    ID              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RBRACE          reduce using rule 24 (stmt -> subCall SEMICOLON .)


state 85

    (25) ifStmt -> IF LPAREN . exp RPAREN ARROW LBRACE block RBRACE
    (26) ifStmt -> IF LPAREN . exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 114
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 86

    (27) whileStmt -> WHILE LPAREN . exp RPAREN ARROW LBRACE block RBRACE
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 115
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 87

    (28) forStmt -> FOR LPAREN . assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUS_EQ exp
    (37) assign -> . var MINUS_EQ exp
    (38) assign -> . var MULTIPLY_EQ exp
    (39) assign -> . var DIVIDE_EQ exp
    (40) assign -> . var MOD exp
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC

    ID              shift and go to state 99

    assign                         shift and go to state 116
    var                            shift and go to state 75

state 88

    (29) breakStmt -> BREAK SEMICOLON .

    IF              reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    READ            reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    WRITE           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    ID              reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)


state 89

    (32) returnStmt -> RETURN SEMICOLON .

    IF              reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    READ            reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    WRITE           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    ID              reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)


state 90

    (33) returnStmt -> RETURN exp . SEMICOLON
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       shift and go to state 117
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 91

    (57) exp -> MINUS . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 132
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 92

    (56) exp -> NOT . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 133
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 93

    (59) exp -> subCall .

    SEMICOLON       reduce using rule 59 (exp -> subCall .)
    PLUS            reduce using rule 59 (exp -> subCall .)
    MINUS           reduce using rule 59 (exp -> subCall .)
    MULTIPLY        reduce using rule 59 (exp -> subCall .)
    DIVIDE          reduce using rule 59 (exp -> subCall .)
    MOD             reduce using rule 59 (exp -> subCall .)
    EQ              reduce using rule 59 (exp -> subCall .)
    DIFF            reduce using rule 59 (exp -> subCall .)
    LE              reduce using rule 59 (exp -> subCall .)
    GE              reduce using rule 59 (exp -> subCall .)
    GT              reduce using rule 59 (exp -> subCall .)
    LT              reduce using rule 59 (exp -> subCall .)
    AND             reduce using rule 59 (exp -> subCall .)
    OR              reduce using rule 59 (exp -> subCall .)
    INTERROGATION   reduce using rule 59 (exp -> subCall .)
    COMMA           reduce using rule 59 (exp -> subCall .)
    RPAREN          reduce using rule 59 (exp -> subCall .)
    RCOLC           reduce using rule 59 (exp -> subCall .)
    COLON           reduce using rule 59 (exp -> subCall .)


state 94

    (60) exp -> var .

    SEMICOLON       reduce using rule 60 (exp -> var .)
    PLUS            reduce using rule 60 (exp -> var .)
    MINUS           reduce using rule 60 (exp -> var .)
    MULTIPLY        reduce using rule 60 (exp -> var .)
    DIVIDE          reduce using rule 60 (exp -> var .)
    MOD             reduce using rule 60 (exp -> var .)
    EQ              reduce using rule 60 (exp -> var .)
    DIFF            reduce using rule 60 (exp -> var .)
    LE              reduce using rule 60 (exp -> var .)
    GE              reduce using rule 60 (exp -> var .)
    GT              reduce using rule 60 (exp -> var .)
    LT              reduce using rule 60 (exp -> var .)
    AND             reduce using rule 60 (exp -> var .)
    OR              reduce using rule 60 (exp -> var .)
    INTERROGATION   reduce using rule 60 (exp -> var .)
    COMMA           reduce using rule 60 (exp -> var .)
    RPAREN          reduce using rule 60 (exp -> var .)
    RCOLC           reduce using rule 60 (exp -> var .)
    COLON           reduce using rule 60 (exp -> var .)


state 95

    (61) exp -> literal .

    SEMICOLON       reduce using rule 61 (exp -> literal .)
    PLUS            reduce using rule 61 (exp -> literal .)
    MINUS           reduce using rule 61 (exp -> literal .)
    MULTIPLY        reduce using rule 61 (exp -> literal .)
    DIVIDE          reduce using rule 61 (exp -> literal .)
    MOD             reduce using rule 61 (exp -> literal .)
    EQ              reduce using rule 61 (exp -> literal .)
    DIFF            reduce using rule 61 (exp -> literal .)
    LE              reduce using rule 61 (exp -> literal .)
    GE              reduce using rule 61 (exp -> literal .)
    GT              reduce using rule 61 (exp -> literal .)
    LT              reduce using rule 61 (exp -> literal .)
    AND             reduce using rule 61 (exp -> literal .)
    OR              reduce using rule 61 (exp -> literal .)
    INTERROGATION   reduce using rule 61 (exp -> literal .)
    COMMA           reduce using rule 61 (exp -> literal .)
    RPAREN          reduce using rule 61 (exp -> literal .)
    RCOLC           reduce using rule 61 (exp -> literal .)
    COLON           reduce using rule 61 (exp -> literal .)


state 96

    (62) exp -> LPAREN . exp RPAREN
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 134
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 97

    (63) exp -> param .

    SEMICOLON       reduce using rule 63 (exp -> param .)
    PLUS            reduce using rule 63 (exp -> param .)
    MINUS           reduce using rule 63 (exp -> param .)
    MULTIPLY        reduce using rule 63 (exp -> param .)
    DIVIDE          reduce using rule 63 (exp -> param .)
    MOD             reduce using rule 63 (exp -> param .)
    EQ              reduce using rule 63 (exp -> param .)
    DIFF            reduce using rule 63 (exp -> param .)
    LE              reduce using rule 63 (exp -> param .)
    GE              reduce using rule 63 (exp -> param .)
    GT              reduce using rule 63 (exp -> param .)
    LT              reduce using rule 63 (exp -> param .)
    AND             reduce using rule 63 (exp -> param .)
    OR              reduce using rule 63 (exp -> param .)
    INTERROGATION   reduce using rule 63 (exp -> param .)
    COMMA           reduce using rule 63 (exp -> param .)
    RPAREN          reduce using rule 63 (exp -> param .)
    RCOLC           reduce using rule 63 (exp -> param .)
    COLON           reduce using rule 63 (exp -> param .)


state 98

    (30) readStmt -> READ var . SEMICOLON

    SEMICOLON       shift and go to state 135


state 99

    (41) var -> ID .
    (42) var -> ID . LCOLC exp RCOLC

    SEMICOLON       reduce using rule 41 (var -> ID .)
    ASSIGN          reduce using rule 41 (var -> ID .)
    PLUS_EQ         reduce using rule 41 (var -> ID .)
    MINUS_EQ        reduce using rule 41 (var -> ID .)
    MULTIPLY_EQ     reduce using rule 41 (var -> ID .)
    DIVIDE_EQ       reduce using rule 41 (var -> ID .)
    MOD             reduce using rule 41 (var -> ID .)
    LCOLC           shift and go to state 111


state 100

    (35) assign -> var ASSIGN . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 136
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 101

    (36) assign -> var PLUS_EQ . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 137
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 102

    (37) assign -> var MINUS_EQ . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 138
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 103

    (38) assign -> var MULTIPLY_EQ . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 139
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 104

    (39) assign -> var DIVIDE_EQ . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 140
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 105

    (40) assign -> var MOD . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    var                            shift and go to state 94
    exp                            shift and go to state 141
    subCall                        shift and go to state 93
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 106

    (31) writeStmt -> WRITE expList . SEMICOLON

    SEMICOLON       shift and go to state 142


state 107

    (76) expList -> expSeq .

    SEMICOLON       reduce using rule 76 (expList -> expSeq .)
    RPAREN          reduce using rule 76 (expList -> expSeq .)


state 108

    (77) expList -> empty .

    SEMICOLON       reduce using rule 77 (expList -> empty .)
    RPAREN          reduce using rule 77 (expList -> empty .)


state 109

    (84) expSeq -> exp . COMMA expSeq
    (85) expSeq -> exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    COMMA           shift and go to state 143
    SEMICOLON       reduce using rule 85 (expSeq -> exp .)
    RPAREN          reduce using rule 85 (expSeq -> exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 110

    (34) subCall -> ID LPAREN . expList RPAREN
    (76) expList -> . expSeq
    (77) expList -> . empty
    (84) expSeq -> . exp COMMA expSeq
    (85) expSeq -> . exp
    (86) empty -> .
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    RPAREN          reduce using rule 86 (empty -> .)
    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    expList                        shift and go to state 144
    expSeq                         shift and go to state 107
    empty                          shift and go to state 108
    exp                            shift and go to state 109
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 111

    (42) var -> ID LCOLC . exp RCOLC
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 145
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 112

    (4) dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .

    FUNC            reduce using rule 4 (dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    NUMBER          reduce using rule 4 (dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    STRING          reduce using rule 4 (dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    BOOL            reduce using rule 4 (dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)
    $end            reduce using rule 4 (dec -> FUNC type ID LPAREN paramList RPAREN ARROW LBRACE block RBRACE .)


state 113

    (78) literalSeq -> literal COMMA literalSeq .

    RBRACE          reduce using rule 78 (literalSeq -> literal COMMA literalSeq .)


state 114

    (25) ifStmt -> IF LPAREN exp . RPAREN ARROW LBRACE block RBRACE
    (26) ifStmt -> IF LPAREN exp . RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    RPAREN          shift and go to state 146
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 115

    (27) whileStmt -> WHILE LPAREN exp . RPAREN ARROW LBRACE block RBRACE
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    RPAREN          shift and go to state 147
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 116

    (28) forStmt -> FOR LPAREN assign . SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE

    SEMICOLON       shift and go to state 148


state 117

    (33) returnStmt -> RETURN exp SEMICOLON .

    IF              reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    READ            reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    WRITE           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    RBRACE          reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)


state 118

    (43) exp -> exp PLUS . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 149
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 119

    (44) exp -> exp MINUS . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 150
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 120

    (45) exp -> exp MULTIPLY . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 151
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 121

    (46) exp -> exp DIVIDE . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 152
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 122

    (47) exp -> exp MOD . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 153
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 123

    (48) exp -> exp EQ . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 154
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 124

    (49) exp -> exp DIFF . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 155
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 125

    (50) exp -> exp LE . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 156
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 126

    (51) exp -> exp GE . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 157
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 127

    (52) exp -> exp GT . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 158
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 128

    (53) exp -> exp LT . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 159
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 129

    (54) exp -> exp AND . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 160
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 130

    (55) exp -> exp OR . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 161
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 131

    (58) exp -> exp INTERROGATION . exp COLON exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 162
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 132

    (57) exp -> MINUS exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 57 (exp -> MINUS exp .)
    PLUS            reduce using rule 57 (exp -> MINUS exp .)
    MINUS           reduce using rule 57 (exp -> MINUS exp .)
    MOD             reduce using rule 57 (exp -> MINUS exp .)
    EQ              reduce using rule 57 (exp -> MINUS exp .)
    DIFF            reduce using rule 57 (exp -> MINUS exp .)
    LE              reduce using rule 57 (exp -> MINUS exp .)
    GE              reduce using rule 57 (exp -> MINUS exp .)
    GT              reduce using rule 57 (exp -> MINUS exp .)
    LT              reduce using rule 57 (exp -> MINUS exp .)
    AND             reduce using rule 57 (exp -> MINUS exp .)
    OR              reduce using rule 57 (exp -> MINUS exp .)
    INTERROGATION   reduce using rule 57 (exp -> MINUS exp .)
    COMMA           reduce using rule 57 (exp -> MINUS exp .)
    RPAREN          reduce using rule 57 (exp -> MINUS exp .)
    RCOLC           reduce using rule 57 (exp -> MINUS exp .)
    COLON           reduce using rule 57 (exp -> MINUS exp .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 57 (exp -> MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 57 (exp -> MINUS exp .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 133

    (56) exp -> NOT exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for INTERROGATION resolved as shift
    SEMICOLON       reduce using rule 56 (exp -> NOT exp .)
    COMMA           reduce using rule 56 (exp -> NOT exp .)
    RPAREN          reduce using rule 56 (exp -> NOT exp .)
    RCOLC           reduce using rule 56 (exp -> NOT exp .)
    COLON           reduce using rule 56 (exp -> NOT exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131

  ! PLUS            [ reduce using rule 56 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> NOT exp .) ]
  ! MULTIPLY        [ reduce using rule 56 (exp -> NOT exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> NOT exp .) ]
  ! EQ              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! DIFF            [ reduce using rule 56 (exp -> NOT exp .) ]
  ! LE              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! GE              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 56 (exp -> NOT exp .) ]
  ! OR              [ reduce using rule 56 (exp -> NOT exp .) ]
  ! INTERROGATION   [ reduce using rule 56 (exp -> NOT exp .) ]


state 134

    (62) exp -> LPAREN exp . RPAREN
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    RPAREN          shift and go to state 163
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 135

    (30) readStmt -> READ var SEMICOLON .

    IF              reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    WHILE           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    FOR             reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    BREAK           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    RETURN          reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    READ            reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    WRITE           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    ID              reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    RBRACE          reduce using rule 30 (readStmt -> READ var SEMICOLON .)


state 136

    (35) assign -> var ASSIGN exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 35 (assign -> var ASSIGN exp .)
    RPAREN          reduce using rule 35 (assign -> var ASSIGN exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 137

    (36) assign -> var PLUS_EQ exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 36 (assign -> var PLUS_EQ exp .)
    RPAREN          reduce using rule 36 (assign -> var PLUS_EQ exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 138

    (37) assign -> var MINUS_EQ exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 37 (assign -> var MINUS_EQ exp .)
    RPAREN          reduce using rule 37 (assign -> var MINUS_EQ exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 139

    (38) assign -> var MULTIPLY_EQ exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 38 (assign -> var MULTIPLY_EQ exp .)
    RPAREN          reduce using rule 38 (assign -> var MULTIPLY_EQ exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 140

    (39) assign -> var DIVIDE_EQ exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 39 (assign -> var DIVIDE_EQ exp .)
    RPAREN          reduce using rule 39 (assign -> var DIVIDE_EQ exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 141

    (40) assign -> var MOD exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 40 (assign -> var MOD exp .)
    RPAREN          reduce using rule 40 (assign -> var MOD exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 142

    (31) writeStmt -> WRITE expList SEMICOLON .

    IF              reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    WHILE           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    FOR             reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    BREAK           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    RETURN          reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    READ            reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    WRITE           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    ID              reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    RBRACE          reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)


state 143

    (84) expSeq -> exp COMMA . expSeq
    (84) expSeq -> . exp COMMA expSeq
    (85) expSeq -> . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 109
    expSeq                         shift and go to state 164
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 144

    (34) subCall -> ID LPAREN expList . RPAREN

    RPAREN          shift and go to state 165


state 145

    (42) var -> ID LCOLC exp . RCOLC
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    RCOLC           shift and go to state 166
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 146

    (25) ifStmt -> IF LPAREN exp RPAREN . ARROW LBRACE block RBRACE
    (26) ifStmt -> IF LPAREN exp RPAREN . ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE

    ARROW           shift and go to state 167


state 147

    (27) whileStmt -> WHILE LPAREN exp RPAREN . ARROW LBRACE block RBRACE

    ARROW           shift and go to state 168


state 148

    (28) forStmt -> FOR LPAREN assign SEMICOLON . exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 169
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 149

    (43) exp -> exp PLUS exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 43 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 43 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 43 (exp -> exp PLUS exp .)
    MOD             reduce using rule 43 (exp -> exp PLUS exp .)
    EQ              reduce using rule 43 (exp -> exp PLUS exp .)
    DIFF            reduce using rule 43 (exp -> exp PLUS exp .)
    LE              reduce using rule 43 (exp -> exp PLUS exp .)
    GE              reduce using rule 43 (exp -> exp PLUS exp .)
    GT              reduce using rule 43 (exp -> exp PLUS exp .)
    LT              reduce using rule 43 (exp -> exp PLUS exp .)
    AND             reduce using rule 43 (exp -> exp PLUS exp .)
    OR              reduce using rule 43 (exp -> exp PLUS exp .)
    INTERROGATION   reduce using rule 43 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 43 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 43 (exp -> exp PLUS exp .)
    RCOLC           reduce using rule 43 (exp -> exp PLUS exp .)
    COLON           reduce using rule 43 (exp -> exp PLUS exp .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 43 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 150

    (44) exp -> exp MINUS exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 44 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 44 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 44 (exp -> exp MINUS exp .)
    MOD             reduce using rule 44 (exp -> exp MINUS exp .)
    EQ              reduce using rule 44 (exp -> exp MINUS exp .)
    DIFF            reduce using rule 44 (exp -> exp MINUS exp .)
    LE              reduce using rule 44 (exp -> exp MINUS exp .)
    GE              reduce using rule 44 (exp -> exp MINUS exp .)
    GT              reduce using rule 44 (exp -> exp MINUS exp .)
    LT              reduce using rule 44 (exp -> exp MINUS exp .)
    AND             reduce using rule 44 (exp -> exp MINUS exp .)
    OR              reduce using rule 44 (exp -> exp MINUS exp .)
    INTERROGATION   reduce using rule 44 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 44 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 44 (exp -> exp MINUS exp .)
    RCOLC           reduce using rule 44 (exp -> exp MINUS exp .)
    COLON           reduce using rule 44 (exp -> exp MINUS exp .)
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! MULTIPLY        [ reduce using rule 44 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 151

    (45) exp -> exp MULTIPLY exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 45 (exp -> exp MULTIPLY exp .)
    PLUS            reduce using rule 45 (exp -> exp MULTIPLY exp .)
    MINUS           reduce using rule 45 (exp -> exp MULTIPLY exp .)
    MULTIPLY        reduce using rule 45 (exp -> exp MULTIPLY exp .)
    DIVIDE          reduce using rule 45 (exp -> exp MULTIPLY exp .)
    MOD             reduce using rule 45 (exp -> exp MULTIPLY exp .)
    EQ              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    DIFF            reduce using rule 45 (exp -> exp MULTIPLY exp .)
    LE              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    GE              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    GT              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    LT              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    AND             reduce using rule 45 (exp -> exp MULTIPLY exp .)
    OR              reduce using rule 45 (exp -> exp MULTIPLY exp .)
    INTERROGATION   reduce using rule 45 (exp -> exp MULTIPLY exp .)
    COMMA           reduce using rule 45 (exp -> exp MULTIPLY exp .)
    RPAREN          reduce using rule 45 (exp -> exp MULTIPLY exp .)
    RCOLC           reduce using rule 45 (exp -> exp MULTIPLY exp .)
    COLON           reduce using rule 45 (exp -> exp MULTIPLY exp .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 152

    (46) exp -> exp DIVIDE exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 46 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 46 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 46 (exp -> exp DIVIDE exp .)
    MULTIPLY        reduce using rule 46 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 46 (exp -> exp DIVIDE exp .)
    MOD             reduce using rule 46 (exp -> exp DIVIDE exp .)
    EQ              reduce using rule 46 (exp -> exp DIVIDE exp .)
    DIFF            reduce using rule 46 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 46 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 46 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 46 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 46 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 46 (exp -> exp DIVIDE exp .)
    OR              reduce using rule 46 (exp -> exp DIVIDE exp .)
    INTERROGATION   reduce using rule 46 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 46 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 46 (exp -> exp DIVIDE exp .)
    RCOLC           reduce using rule 46 (exp -> exp DIVIDE exp .)
    COLON           reduce using rule 46 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 118 ]
  ! MINUS           [ shift and go to state 119 ]
  ! MULTIPLY        [ shift and go to state 120 ]
  ! DIVIDE          [ shift and go to state 121 ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 153

    (47) exp -> exp MOD exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for INTERROGATION resolved as shift
    SEMICOLON       reduce using rule 47 (exp -> exp MOD exp .)
    COMMA           reduce using rule 47 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 47 (exp -> exp MOD exp .)
    RCOLC           reduce using rule 47 (exp -> exp MOD exp .)
    COLON           reduce using rule 47 (exp -> exp MOD exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131

  ! PLUS            [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! MULTIPLY        [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! EQ              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! DIFF            [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! LE              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! GE              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! GT              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! LT              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! AND             [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! OR              [ reduce using rule 47 (exp -> exp MOD exp .) ]
  ! INTERROGATION   [ reduce using rule 47 (exp -> exp MOD exp .) ]


state 154

    (48) exp -> exp EQ exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 48 (exp -> exp EQ exp .)
    MOD             reduce using rule 48 (exp -> exp EQ exp .)
    EQ              reduce using rule 48 (exp -> exp EQ exp .)
    DIFF            reduce using rule 48 (exp -> exp EQ exp .)
    AND             reduce using rule 48 (exp -> exp EQ exp .)
    OR              reduce using rule 48 (exp -> exp EQ exp .)
    INTERROGATION   reduce using rule 48 (exp -> exp EQ exp .)
    COMMA           reduce using rule 48 (exp -> exp EQ exp .)
    RPAREN          reduce using rule 48 (exp -> exp EQ exp .)
    RCOLC           reduce using rule 48 (exp -> exp EQ exp .)
    COLON           reduce using rule 48 (exp -> exp EQ exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128

  ! PLUS            [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! MULTIPLY        [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! LE              [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! GE              [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! GT              [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! LT              [ reduce using rule 48 (exp -> exp EQ exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 155

    (49) exp -> exp DIFF exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 49 (exp -> exp DIFF exp .)
    MOD             reduce using rule 49 (exp -> exp DIFF exp .)
    EQ              reduce using rule 49 (exp -> exp DIFF exp .)
    DIFF            reduce using rule 49 (exp -> exp DIFF exp .)
    AND             reduce using rule 49 (exp -> exp DIFF exp .)
    OR              reduce using rule 49 (exp -> exp DIFF exp .)
    INTERROGATION   reduce using rule 49 (exp -> exp DIFF exp .)
    COMMA           reduce using rule 49 (exp -> exp DIFF exp .)
    RPAREN          reduce using rule 49 (exp -> exp DIFF exp .)
    RCOLC           reduce using rule 49 (exp -> exp DIFF exp .)
    COLON           reduce using rule 49 (exp -> exp DIFF exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128

  ! PLUS            [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! MULTIPLY        [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! LE              [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! GE              [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! GT              [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! LT              [ reduce using rule 49 (exp -> exp DIFF exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 156

    (50) exp -> exp LE exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 50 (exp -> exp LE exp .)
    MOD             reduce using rule 50 (exp -> exp LE exp .)
    EQ              reduce using rule 50 (exp -> exp LE exp .)
    DIFF            reduce using rule 50 (exp -> exp LE exp .)
    LE              reduce using rule 50 (exp -> exp LE exp .)
    GE              reduce using rule 50 (exp -> exp LE exp .)
    GT              reduce using rule 50 (exp -> exp LE exp .)
    LT              reduce using rule 50 (exp -> exp LE exp .)
    AND             reduce using rule 50 (exp -> exp LE exp .)
    OR              reduce using rule 50 (exp -> exp LE exp .)
    INTERROGATION   reduce using rule 50 (exp -> exp LE exp .)
    COMMA           reduce using rule 50 (exp -> exp LE exp .)
    RPAREN          reduce using rule 50 (exp -> exp LE exp .)
    RCOLC           reduce using rule 50 (exp -> exp LE exp .)
    COLON           reduce using rule 50 (exp -> exp LE exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! PLUS            [ reduce using rule 50 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp LE exp .) ]
  ! MULTIPLY        [ reduce using rule 50 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 50 (exp -> exp LE exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 157

    (51) exp -> exp GE exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 51 (exp -> exp GE exp .)
    MOD             reduce using rule 51 (exp -> exp GE exp .)
    EQ              reduce using rule 51 (exp -> exp GE exp .)
    DIFF            reduce using rule 51 (exp -> exp GE exp .)
    LE              reduce using rule 51 (exp -> exp GE exp .)
    GE              reduce using rule 51 (exp -> exp GE exp .)
    GT              reduce using rule 51 (exp -> exp GE exp .)
    LT              reduce using rule 51 (exp -> exp GE exp .)
    AND             reduce using rule 51 (exp -> exp GE exp .)
    OR              reduce using rule 51 (exp -> exp GE exp .)
    INTERROGATION   reduce using rule 51 (exp -> exp GE exp .)
    COMMA           reduce using rule 51 (exp -> exp GE exp .)
    RPAREN          reduce using rule 51 (exp -> exp GE exp .)
    RCOLC           reduce using rule 51 (exp -> exp GE exp .)
    COLON           reduce using rule 51 (exp -> exp GE exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! PLUS            [ reduce using rule 51 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp GE exp .) ]
  ! MULTIPLY        [ reduce using rule 51 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp GE exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 158

    (52) exp -> exp GT exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 52 (exp -> exp GT exp .)
    MOD             reduce using rule 52 (exp -> exp GT exp .)
    EQ              reduce using rule 52 (exp -> exp GT exp .)
    DIFF            reduce using rule 52 (exp -> exp GT exp .)
    LE              reduce using rule 52 (exp -> exp GT exp .)
    GE              reduce using rule 52 (exp -> exp GT exp .)
    GT              reduce using rule 52 (exp -> exp GT exp .)
    LT              reduce using rule 52 (exp -> exp GT exp .)
    AND             reduce using rule 52 (exp -> exp GT exp .)
    OR              reduce using rule 52 (exp -> exp GT exp .)
    INTERROGATION   reduce using rule 52 (exp -> exp GT exp .)
    COMMA           reduce using rule 52 (exp -> exp GT exp .)
    RPAREN          reduce using rule 52 (exp -> exp GT exp .)
    RCOLC           reduce using rule 52 (exp -> exp GT exp .)
    COLON           reduce using rule 52 (exp -> exp GT exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! PLUS            [ reduce using rule 52 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp GT exp .) ]
  ! MULTIPLY        [ reduce using rule 52 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp GT exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 159

    (53) exp -> exp LT exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 53 (exp -> exp LT exp .)
    MOD             reduce using rule 53 (exp -> exp LT exp .)
    EQ              reduce using rule 53 (exp -> exp LT exp .)
    DIFF            reduce using rule 53 (exp -> exp LT exp .)
    LE              reduce using rule 53 (exp -> exp LT exp .)
    GE              reduce using rule 53 (exp -> exp LT exp .)
    GT              reduce using rule 53 (exp -> exp LT exp .)
    LT              reduce using rule 53 (exp -> exp LT exp .)
    AND             reduce using rule 53 (exp -> exp LT exp .)
    OR              reduce using rule 53 (exp -> exp LT exp .)
    INTERROGATION   reduce using rule 53 (exp -> exp LT exp .)
    COMMA           reduce using rule 53 (exp -> exp LT exp .)
    RPAREN          reduce using rule 53 (exp -> exp LT exp .)
    RCOLC           reduce using rule 53 (exp -> exp LT exp .)
    COLON           reduce using rule 53 (exp -> exp LT exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121

  ! PLUS            [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MULTIPLY        [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp LT exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! EQ              [ shift and go to state 123 ]
  ! DIFF            [ shift and go to state 124 ]
  ! LE              [ shift and go to state 125 ]
  ! GE              [ shift and go to state 126 ]
  ! GT              [ shift and go to state 127 ]
  ! LT              [ shift and go to state 128 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 160

    (54) exp -> exp AND exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 54 (exp -> exp AND exp .)
    MOD             reduce using rule 54 (exp -> exp AND exp .)
    AND             reduce using rule 54 (exp -> exp AND exp .)
    OR              reduce using rule 54 (exp -> exp AND exp .)
    INTERROGATION   reduce using rule 54 (exp -> exp AND exp .)
    COMMA           reduce using rule 54 (exp -> exp AND exp .)
    RPAREN          reduce using rule 54 (exp -> exp AND exp .)
    RCOLC           reduce using rule 54 (exp -> exp AND exp .)
    COLON           reduce using rule 54 (exp -> exp AND exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128

  ! PLUS            [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! MULTIPLY        [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! EQ              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! DIFF            [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! AND             [ shift and go to state 129 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 161

    (55) exp -> exp OR exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       reduce using rule 55 (exp -> exp OR exp .)
    MOD             reduce using rule 55 (exp -> exp OR exp .)
    OR              reduce using rule 55 (exp -> exp OR exp .)
    INTERROGATION   reduce using rule 55 (exp -> exp OR exp .)
    COMMA           reduce using rule 55 (exp -> exp OR exp .)
    RPAREN          reduce using rule 55 (exp -> exp OR exp .)
    RCOLC           reduce using rule 55 (exp -> exp OR exp .)
    COLON           reduce using rule 55 (exp -> exp OR exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129

  ! PLUS            [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! MULTIPLY        [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! EQ              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! DIFF            [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! MOD             [ shift and go to state 122 ]
  ! OR              [ shift and go to state 130 ]
  ! INTERROGATION   [ shift and go to state 131 ]


state 162

    (58) exp -> exp INTERROGATION exp . COLON exp
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    COLON           shift and go to state 170
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 163

    (62) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    MULTIPLY        reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    EQ              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    INTERROGATION   reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    RCOLC           reduce using rule 62 (exp -> LPAREN exp RPAREN .)
    COLON           reduce using rule 62 (exp -> LPAREN exp RPAREN .)


state 164

    (84) expSeq -> exp COMMA expSeq .

    SEMICOLON       reduce using rule 84 (expSeq -> exp COMMA expSeq .)
    RPAREN          reduce using rule 84 (expSeq -> exp COMMA expSeq .)


state 165

    (34) subCall -> ID LPAREN expList RPAREN .

    SEMICOLON       reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    PLUS            reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MINUS           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MULTIPLY        reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    DIVIDE          reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MOD             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    EQ              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    DIFF            reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    LE              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    GE              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    GT              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    LT              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    AND             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    OR              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    INTERROGATION   reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    COMMA           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    RPAREN          reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    RCOLC           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    COLON           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)


state 166

    (42) var -> ID LCOLC exp RCOLC .

    ASSIGN          reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    PLUS_EQ         reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    MINUS_EQ        reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    MULTIPLY_EQ     reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    DIVIDE_EQ       reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    MOD             reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    SEMICOLON       reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    PLUS            reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    MINUS           reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    MULTIPLY        reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    DIVIDE          reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    EQ              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    DIFF            reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    LE              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    GE              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    GT              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    LT              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    AND             reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    OR              reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    INTERROGATION   reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    COMMA           reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    RPAREN          reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    RCOLC           reduce using rule 42 (var -> ID LCOLC exp RCOLC .)
    COLON           reduce using rule 42 (var -> ID LCOLC exp RCOLC .)


state 167

    (25) ifStmt -> IF LPAREN exp RPAREN ARROW . LBRACE block RBRACE
    (26) ifStmt -> IF LPAREN exp RPAREN ARROW . RBRACE block RBRACE ELSE LBRACE block RBRACE

    LBRACE          shift and go to state 171
    RBRACE          shift and go to state 172


state 168

    (27) whileStmt -> WHILE LPAREN exp RPAREN ARROW . LBRACE block RBRACE

    LBRACE          shift and go to state 173


state 169

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp . SEMICOLON assign RPAREN ARROW LBRACE block RBRACE
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

    SEMICOLON       shift and go to state 174
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131


state 170

    (58) exp -> exp INTERROGATION exp COLON . exp
    (43) exp -> . exp PLUS exp
    (44) exp -> . exp MINUS exp
    (45) exp -> . exp MULTIPLY exp
    (46) exp -> . exp DIVIDE exp
    (47) exp -> . exp MOD exp
    (48) exp -> . exp EQ exp
    (49) exp -> . exp DIFF exp
    (50) exp -> . exp LE exp
    (51) exp -> . exp GE exp
    (52) exp -> . exp GT exp
    (53) exp -> . exp LT exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . NOT exp
    (57) exp -> . MINUS exp
    (58) exp -> . exp INTERROGATION exp COLON exp
    (59) exp -> . subCall
    (60) exp -> . var
    (61) exp -> . literal
    (62) exp -> . LPAREN exp RPAREN
    (63) exp -> . param
    (34) subCall -> . ID LPAREN expList RPAREN
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC
    (64) literal -> . CONST_NUMBER
    (65) literal -> . CONST_STRING
    (66) literal -> . TRUE
    (67) literal -> . FALSE
    (13) param -> . type ID
    (14) param -> . type ID LCOLC RCOLC
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    NOT             shift and go to state 92
    MINUS           shift and go to state 91
    LPAREN          shift and go to state 96
    ID              shift and go to state 77
    CONST_NUMBER    shift and go to state 30
    CONST_STRING    shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    exp                            shift and go to state 175
    subCall                        shift and go to state 93
    var                            shift and go to state 94
    literal                        shift and go to state 95
    param                          shift and go to state 97
    type                           shift and go to state 26

state 171

    (25) ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 176
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 172

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE . block RBRACE ELSE LBRACE block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 177
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 173

    (27) whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 178
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 174

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON . assign RPAREN ARROW LBRACE block RBRACE
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUS_EQ exp
    (37) assign -> . var MINUS_EQ exp
    (38) assign -> . var MULTIPLY_EQ exp
    (39) assign -> . var DIVIDE_EQ exp
    (40) assign -> . var MOD exp
    (41) var -> . ID
    (42) var -> . ID LCOLC exp RCOLC

    ID              shift and go to state 99

    assign                         shift and go to state 179
    var                            shift and go to state 75

state 175

    (58) exp -> exp INTERROGATION exp COLON exp .
    (43) exp -> exp . PLUS exp
    (44) exp -> exp . MINUS exp
    (45) exp -> exp . MULTIPLY exp
    (46) exp -> exp . DIVIDE exp
    (47) exp -> exp . MOD exp
    (48) exp -> exp . EQ exp
    (49) exp -> exp . DIFF exp
    (50) exp -> exp . LE exp
    (51) exp -> exp . GE exp
    (52) exp -> exp . GT exp
    (53) exp -> exp . LT exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (58) exp -> exp . INTERROGATION exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for INTERROGATION resolved as shift
    SEMICOLON       reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .)
    COMMA           reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .)
    RPAREN          reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .)
    RCOLC           reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .)
    COLON           reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .)
    PLUS            shift and go to state 118
    MINUS           shift and go to state 119
    MULTIPLY        shift and go to state 120
    DIVIDE          shift and go to state 121
    MOD             shift and go to state 122
    EQ              shift and go to state 123
    DIFF            shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    GT              shift and go to state 127
    LT              shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130
    INTERROGATION   shift and go to state 131

  ! PLUS            [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! MINUS           [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! MULTIPLY        [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! DIVIDE          [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! MOD             [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! EQ              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! DIFF            [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! LE              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! GE              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! GT              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! LT              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! AND             [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! OR              [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]
  ! INTERROGATION   [ reduce using rule 58 (exp -> exp INTERROGATION exp COLON exp .) ]


state 176

    (25) ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block . RBRACE

    RBRACE          shift and go to state 180


state 177

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block . RBRACE ELSE LBRACE block RBRACE

    RBRACE          shift and go to state 181


state 178

    (27) whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block . RBRACE

    RBRACE          shift and go to state 182


state 179

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign . RPAREN ARROW LBRACE block RBRACE

    RPAREN          shift and go to state 183


state 180

    (25) ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .

    IF              reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    WHILE           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    FOR             reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    BREAK           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    RETURN          reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    READ            reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    WRITE           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    ID              reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    RBRACE          reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN ARROW LBRACE block RBRACE .)


state 181

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE . ELSE LBRACE block RBRACE

    ELSE            shift and go to state 184


state 182

    (27) whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .

    IF              reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    WHILE           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    FOR             reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    BREAK           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    RETURN          reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    READ            reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    WRITE           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    ID              reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)
    RBRACE          reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN ARROW LBRACE block RBRACE .)


state 183

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN . ARROW LBRACE block RBRACE

    ARROW           shift and go to state 185


state 184

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE . LBRACE block RBRACE

    LBRACE          shift and go to state 186


state 185

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW . LBRACE block RBRACE

    LBRACE          shift and go to state 187


state 186

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 188
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 187

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE . block RBRACE
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . NUMBER
    (11) type -> . STRING
    (12) type -> . BOOL

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)
    NUMBER          shift and go to state 7
    STRING          shift and go to state 8
    BOOL            shift and go to state 9

    block                          shift and go to state 189
    varDecList                     shift and go to state 50
    varDec                         shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 6

state 188

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block . RBRACE

    RBRACE          shift and go to state 190


state 189

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block . RBRACE

    RBRACE          shift and go to state 191


state 190

    (26) ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .

    IF              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    WHILE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    FOR             reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    BREAK           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    RETURN          reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    READ            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    WRITE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    ID              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)
    RBRACE          reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN ARROW RBRACE block RBRACE ELSE LBRACE block RBRACE .)


state 191

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .

    IF              reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    WHILE           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    FOR             reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    BREAK           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    RETURN          reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    READ            reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    WRITE           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    ID              reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)
    RBRACE          reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN ARROW LBRACE block RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 133 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 133 resolved as shift
WARNING: shift/reduce conflict for MOD in state 133 resolved as shift
WARNING: shift/reduce conflict for EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 133 resolved as shift
WARNING: shift/reduce conflict for LE in state 133 resolved as shift
WARNING: shift/reduce conflict for GE in state 133 resolved as shift
WARNING: shift/reduce conflict for GT in state 133 resolved as shift
WARNING: shift/reduce conflict for LT in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for INTERROGATION in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 153 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 153 resolved as shift
WARNING: shift/reduce conflict for MOD in state 153 resolved as shift
WARNING: shift/reduce conflict for EQ in state 153 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 153 resolved as shift
WARNING: shift/reduce conflict for LE in state 153 resolved as shift
WARNING: shift/reduce conflict for GE in state 153 resolved as shift
WARNING: shift/reduce conflict for GT in state 153 resolved as shift
WARNING: shift/reduce conflict for LT in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 153 resolved as shift
WARNING: shift/reduce conflict for OR in state 153 resolved as shift
WARNING: shift/reduce conflict for INTERROGATION in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 175 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 175 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for MOD in state 175 resolved as shift
WARNING: shift/reduce conflict for EQ in state 175 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 175 resolved as shift
WARNING: shift/reduce conflict for LE in state 175 resolved as shift
WARNING: shift/reduce conflict for GE in state 175 resolved as shift
WARNING: shift/reduce conflict for GT in state 175 resolved as shift
WARNING: shift/reduce conflict for LT in state 175 resolved as shift
WARNING: shift/reduce conflict for AND in state 175 resolved as shift
WARNING: shift/reduce conflict for OR in state 175 resolved as shift
WARNING: shift/reduce conflict for INTERROGATION in state 175 resolved as shift
